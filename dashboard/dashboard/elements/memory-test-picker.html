<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/components/iron-icons/iron-icons.html">
<link rel="import" href="/components/paper-button/paper-button.html">
<link rel="import" href="/components/paper-input/paper-input.html">
<link rel="import" href="/components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/components/paper-progress/paper-progress.html">

<link rel="import" href="/dashboard/elements/autocomplete-box.html">
<link rel="import" href="/dashboard/static/simple_xhr.html">
<link rel="import" href="/dashboard/static/testselection.html">

<dom-module id="memory-test-picker">
  <template>
    <style include="iron-flex iron-flex-alignment">
      paper-input {
        max-width: 33%;
      }

      .graph-spec paper-button {
        margin-left: 0px;
        margin-right: 0px;
        color: #4285f4;
      }

      .graph-spec paper-icon-button {
        color: #212121;
      }

      .graph-spec p {
        margin: 8px;
      }
      
      .dimension {
        float: left;
      }

      .filter {
        clear: both;
      }

      .filter .layout {
        align-items: center;
      }
    </style>

    <div id="container">
      <template is="dom-if" if="{{length_(graphSpecs)}}">
        <div class="filter">
          <paper-input
              label="Filter"
              value="{{query}}">
          </paper-input>
          <template is="dom-repeat" items="{{series}}" as="value">
            <div>
              <input
                  type="checkbox"
                  id="{{value.id}}"
                  checked="[[isSelectedValue_(valueIdToSelected.*, value)]]" 
                  on-change="handleCheckboxChanged_" 
                  style="vertical-align: middle;"></input>
              <label for$="{{value.id}}">
                  {{value.dimension.label}}: {{value.label}}
              </label>
            </div>
          </template>
        </div>

        <div class="dimensions">
          <template is="dom-repeat" items="{{dimensions}}" as="dimension">
            <div class="dimension">
              {{dimension.label}}
              <template is="dom-repeat" items="{{selected}}" as="value">
                <div>
                  <input
                      type="checkbox"
                      id="{{dimension.id}}-{{value.id}}"
                      checked="[[isSelectedValue_(valueIdToSelected.*, value)]]" 
                      on-change="handleCheckboxChanged_" 
                      style="vertical-align: middle;"></input>
                  <label for$="{{dimension.id}}-{{value.id}}">
                    {{value.label}}
                  </label>
                </div>
              </template>
            </div>
          </template>
        </div>
      </template>
      <template is="dom-if" if="{{!length_(graphSpecs)}}">
          <p>Select a device test suite and device above</p>
      </template>
    </div>
  </template>
  <script>
    'use strict';

    var FuzzySelect = function(items, opt_accessor) {
      this.accessor = opt_accessor || ((s) => s); 
      this.items = items;
    }

    FuzzySelect.prototype.filter = function(query) {
      var r = new RegExp('.*'+query.split('').join('.*')+'.*');
      return this.items.filter((item) => r.exec(this.accessor(item)));
    };

    var ArrayPool = function() {
        this.tree = new Map();
        this.empty = Object();
    };

    ArrayPool.prototype.deduplicate = function(array) {
      var tree = this.tree;
      for (var item of array) {
        if (!tree.has(item)) {
          tree.set(item, new Map());
        }
        tree = tree.get(item);
      }
      if (!tree.has(this.empty)) {
        tree.set(this.empty, array);
      }
      return tree.get(this.empty);
    };

    var Dimension = function(label, id, opt_additive) {
      function check(name, v) {
        if (v === undefined) {
          throw new Error('In Dimension "' + name + '" undefined.');
        }
        return v;
      }
      this.label = check('label', label);
      this.id = check('id', id);
      this.additive = opt_additive === undefined ? false : opt_additive;
    };

    var Value = function(path, dimension) {
      function check(name, v) {
        if (v === undefined) {
          throw new Error('In Value "' + name + '" undefined.');
        }
        return v;
      }
      this.path = check('path', path);
      this.dimension = check('dimension', dimension);
      this.id = this.dimension.id + '.' + this.path.join('-');
      this.label = this.path.join(' / ');
    };

    var Selection = function(value) {
      function check(name, v) {
        if (v === undefined) {
          throw new Error('In Selection"' + name + '" undefined.');
        }
        return v;
      }
      this.value = value;
      this.dimension = this.value.dimension;
      this.id = this.value.id;
      this.selected = false;
      this.disabled = false;
    }

    var MemoryGraphSpec = function(config) {
      function check(name) {
        if (config[name] === undefined) {
          throw new Error('In MemoryGraphSpec "' + name + '" undefined.');
        }
        return config[name];
      }
      this.suite = 'system_health.memory_mobile';
      this.bot = check('bot');
      this.browser = check('browser');
      this.processes = check('processes');
      this.metricPath = check('metricPath');
      this.storyPath = check('storyPath');

      this.storyGroup = check('storyGroup');
      this.storyName = check('storyName');
    };

    MemoryGraphSpec.fromFlattenedSubtestDictEntry = function(bot, entry) {
      var [_, browser, processes] = entry[0].split(':', 3);
      var metricPath = entry[0].split(':').slice(3);
      var storyGroup = entry[1];
      var storyName = entry[2];
      var storyPath = entry[2].split('_');
      return new MemoryGraphSpec({
        bot: bot,
        browser: browser,
        processes: processes,
        metricPath: metricPath,
        storyPath: storyPath,
        storyGroup: storyGroup,
        storyName: storyName,
      });
    };

    MemoryGraphSpec.prototype = {
      get path() {
        return 'ChromiumPerf/' + this.bot + '/' + this.suite + '/' +
            'memory:' + this.browser + ':' + this.processes + ':' +
            this.metricPath.join(':') + '/' + this.storyGroup + '/' +
            this.storyName;
      },

      get testPathAndSeries() {
        return [this.path, [this.storyName]];
      },

      get humanName() {
        return this.browser + ':' + this.processes + ':' + 
            this.metricPath.join(':') + '/' + this.storyGroup +
            '/' + this.storyName;
      }
    };

    Polymer({
      is: 'memory-test-picker',

      properties: {
        query: {
          type: String,
          notify: true,
          value: () => '',
        },

        graphSpecs: {
          type: Array,
          value: () => [],
        },

        dimensions: {
          type: Array,
          value: () => [
            new Dimension('Device', 'bot'),
            new Dimension('Browser', 'browser'),
            new Dimension('Proccess', 'processes'),
            new Dimension('Story', 'storyPath'),
            new Dimension('Metric', 'metricPath'),
          ],
        },

        selections: {
          type: Object,
          value: () => { return {}; },
        },

        dimensionToValues: {
          type: Object,
          computed: 'dimensionToValues_(graphSpecs, dimensions)',
        },

        valueIdToSelected: {
          type: Object,
          notify: true,
          value: () => { return {}; },
        },

        matchingValues: {
          type: Array,
          computed: 'matchingValues_(query, dimensionToValues)',
        },

        selectedGraphSpecs: {
          type: Object,
          computed: 'selectedGraphSpecs_(selectedValues)',
        },

        selectedPathsAndSeries: {
          type: Array,
          value: () => [],
        },
      },

      updateSubtestDict: function(bot, subtestDict) {
        var flattenedDict = [...this.flattenSubtestDict_(subtestDict)];
        this.graphSpecs = flattenedDict.map(function(entry) {
          return MemoryGraphSpec.fromFlattenedSubtestDictEntry(bot, entry);
        });
      },

      matchingValues_: function(query, dimensionToValues) {
        if (query === '') {
          return [];
        }
        var values = [].concat.apply([], Array.from(dimensionToValues.values()));
        var selector = new FuzzySelect(values, (value) => value.label);
        var matches = selector.filter(query);
        return matches.slice(0, 30);
      },

      /**
       * The graphs specs selected by the user.
       */
      selectedGraphSpecs_: function(selectedValues) {
        var selectedValues = this.dimensionToValues.values();
        this.product_();
        return [];
      },

      /**
       * Template helper to get the length of an array.
       */
      length_: function(arr) {
        return arr.length;
      },

      product_: function() {
        if (arguments.length === 1) {
          return arguments[0].map((x) => [x]);
        }
        var args = Array.from(arguments);
        var xs  = args.shift();
        var yss = this.product_.apply(this, args);
        var results = [];
        for (x of xs) {
          for (ys of yss) {
            results.push([x].concat(ys));
          }
        }
        return results;
      },

      /**
       * Handler for adding a new graph.
       */
      handleGraphSpecAdd_(e) {
        var item = e.model.item;
        var pathAndSeries = item.testPathAndSeries;
        this.push('selectedPathsAndSeries', pathAndSeries);
      },

      /**
       * Handler for adding a new graph.
       */
      handleCheckboxChanged_(e) {
        var checked = e.target.checked;
        var value = e.model.value;
        this.set(['valueIdToSelected', value.id], checked);
      },

      isSelectedValue_: function(_valueIdToSelected, value) {
        var selected = this.get(['valueIdToSelected', value.id]);
        if (selected === undefined) return false;
        return selected;
      },

      /**
       * Handler for dragging a graph spec onto an existing graph.
       */
      handleGraphSpecDragStart_: function(event, detail) {
        var item = event.model.item;
        var testPathAndSeries = item.testPathAndSeries;
        event.dataTransfer.setData('type', 'seriesdnd');
        event.dataTransfer.setData('data', JSON.stringify(testPathAndSeries));
        event.dataTransfer.effectAllowed = 'copy';
      },

      dimensionToValues_: function(graphSpecs, dimensions) {
        var dimenToSet = new Map();
        var pool = new ArrayPool();
        dimensions.forEach((d) => { dimenToSet.set(d, new Set()); });
        for (var spec of graphSpecs) {
          for (var dimension of dimensions) {
            var valuePath = spec[dimension.id];
            if (typeof valuePath == 'string') valuePath = [valuePath];
            valuePath = pool.deduplicate(valuePath);
            dimenToSet.get(dimension).add(valuePath);
          }
        }
        var idToArray = new Map();
        for (var dimen of dimenToSet.keys()) {
          idToArray.set(dimen.id, Array.from(dimenToSet.get(dimen)).map((valueId) => new Value(valueId, dimen)));
          idToArray.get(dimen.id).sort((a, b) => {
            if (a.label < b.label) return -1;
            if (a.label > b.label) return 1;
            return 0;
          });
        }
        return idToArray;
      },

      getValuesForDimension_: function(dimensionId) {
        return this.dimensionToValues.get(dimensionId);
      },

      flattenSubtestDict_: function* (subtestDict) {
        for (var key in subtestDict) {
          var test = subtestDict[key];
          var subtests = test['sub_tests'];
          if (subtests && Object.keys(subtests).length > 0) {
            for (var a of this.flattenSubtestDict_(subtests)) {
              yield [key].concat(a);
            }
          } else {
            yield [key];
          }
        }
      }
    });
  </script>
</dom-module>
